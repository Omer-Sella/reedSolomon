![workflow badge](https://github.com/Omer-Sella/reedSolomon/actions/workflows/arithmetic.yml/badge.svg)
![workflow badge](https://github.com/Omer-Sella/reedSolomon/actions/workflows/keyEquationSolver.yml/badge.svg)
![workflow badge](https://github.com/Omer-Sella/reedSolomon/actions/workflows/bchDecoder.yml/badge.svg)

Code for BCH / Reed-Solomon encoder/decoder pair.\
# Table of contents
1. [Mathematics of Reed Solomon and BCH codes](#mathematics)
2. [Implementation notes](#implementation)


## This is the introduction <a name="mathematics"></a>
Some (out of order) overview of Reed Solomon and BCH codes, in the context of this code:\
A message $m(X)$ is a polynomial with coefficients in a finite field $F$ with $char(F) = 2$.\
Meaning, the coefficients of $c(X)$ are bit vectors, addition $\oplus$ of vectors is bitwise XOR (or sum modulu 2), $1$ is the vector with all 0s EXCEPT THE RIGHTMOST COORDINATE, and multiplication $\cdot$ needs to be defined over $F$, such that:\
$\forall \alpha 1\cdot \alpha = \alpha \cdot 1 = \alpha$
$\forall \alpha, \beta \in F: \alpha \cdot \beta \in F$ \
$\forall \alpha, \beta \in F: \beta \cdot \alpha = \alpha \cdot \beta$ \
$\forall \alpha, \beta, \gamma \in F: \alpha\cdot(\beta \cdot \gamma) = (\alpha\cdot\beta) \cdot \gamma$ \
$\forall \alpha, \beta, \gamma \in F: \alpha\cdot(\beta \oplus \gamma) = (\alpha\cdot\beta) \oplus (\alpha \cdot \gamma)$ \
$\forall \alpha, \beta, \gamma \in F: \alpha\cdot(\beta \oplus \gamma) = (\alpha\cdot\beta) \oplus (\alpha \cdot \gamma)$ \
$\forall \alpha \neq 0 \exists \beta : \alpha \cdot \beta = 1$ \
Formally, there need to be further axioms here regarding addition, but once I said it's bitwise XOR they are automatically fulfilled.\
The above arithmetic is implemented ad-hoc for a field of size $2^8$ as well as $2^7$, in arithmetic.py.\
Given a field $F$ we consider $F[x]$, the ring of formal polynomials in variable $x$ over $F$, namely the set of expressions: $$\{\Sigma_{i=0}^{K}a_i \cdot x^i\ : a_i \in F\}$$.\
Given a polynomial $g(x)\in F[X]$, we denote the (left) ideal generated by $g(x)$ : $$<g(x)> = {g(x) \cdot a(x): a(x) \in F[x]\} $$. \
The space of codewords is then the ideal generated by $g(x)$. By definition of $g(x)$, and given a message $m(x)$, we can check if $m(x)$ is a codeword using Euclid's division algorithm (also implemented in arithmetic.py), by computing $m(x)$ modulu $g(x)$ and checking whether it is $0$ modulu $g(x)$.

### Implementation notes<a name="implementation"></a>
Implementation notes
